<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Game FPS 3D Sederhana - Demo WebGL</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #111;
            color: white;
            font-family: Arial, sans-serif;
            overflow: hidden;
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        .ui {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 10;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px;
        }
        .ui h2 {
            margin: 0 0 10px 0;
        }
        .ui p {
            margin: 5px 0;
        }
        .instructions {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            text-align: center;
        }
    </style>
</head>
<body>
    <div class="ui">
        <h2>Game FPS 3D Demo</h2>
        <p>Movement: WASD atau Arrow Keys</p>
        <p>Look Around: Mouse</p>
        <p>Jump: Space</p>
        <p>Objective: Jelajahi lingkungan 3D</p>
        <p>Position: <span id="position">0,0,0</span></p>
    </div>
    <div class="instructions">
        <p>Ini adalah demo game FPS 3D sederhana menggunakan WebGL murni. Jelajahi kubus-kubus di sekitar!</p>
    </div>
    <canvas id="glcanvas"></canvas>

    <script>
        // WebGL Context
        const canvas = document.getElementById('glcanvas');
        const gl = canvas.getContext('webgl');
        if (!gl) {
            alert('WebGL not supported');
            throw new Error('WebGL not supported');
        }

        // Resize canvas
        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            gl.viewport(0, 0, canvas.width, canvas.height);
        }
        window.addEventListener('resize', resize);
        resize();

        // Shader sources
        const vertexShaderSource = `
            attribute vec4 aVertexPosition;
            attribute vec4 aVertexColor;
            uniform mat4 uModelViewMatrix;
            uniform mat4 uProjectionMatrix;
            varying lowp vec4 vColor;
            void main(void) {
                gl_Position = uProjectionMatrix * uModelViewMatrix * aVertexPosition;
                vColor = aVertexColor;
            }
        `;

        const fragmentShaderSource = `
            varying lowp vec4 vColor;
            void main(void) {
                gl_FragColor = vColor;
            }
        `;

        // Shader compilation
        function loadShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('Error compiling shader:', gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

        const vertexShader = loadShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
        const fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
        const shaderProgram = gl.createProgram();
        gl.attachShader(shaderProgram, vertexShader);
        gl.attachShader(shaderProgram, fragmentShader);
        gl.linkProgram(shaderProgram);

        if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
            console.error('Error linking shader program:', gl.getProgramInfoLog(shaderProgram));
        }

        gl.useProgram(shaderProgram);

        const programInfo = {
            program: shaderProgram,
            attribLocations: {
                vertexPosition: gl.getAttribLocation(shaderProgram, 'aVertexPosition'),
                vertexColor: gl.getAttribLocation(shaderProgram, 'aVertexColor'),
            },
            uniformLocations: {
                projectionMatrix: gl.getUniformLocation(shaderProgram, 'uProjectionMatrix'),
                modelViewMatrix: gl.getUniformLocation(shaderProgram, 'uModelViewMatrix'),
            },
        };

        // Cube data
        const positions = [
            // Front face
            -1.0, -1.0,  1.0,
             1.0, -1.0,  1.0,
             1.0,  1.0,  1.0,
            -1.0,  1.0,  1.0,

            // Back face
            -1.0, -1.0, -1.0,
            -1.0,  1.0, -1.0,
             1.0,  1.0, -1.0,
             1.0, -1.0, -1.0,

            // Top face
            -1.0,  1.0, -1.0,
            -1.0,  1.0,  1.0,
             1.0,  1.0,  1.0,
             1.0,  1.0, -1.0,

            // Bottom face
            -1.0, -1.0, -1.0,
             1.0, -1.0, -1.0,
             1.0, -1.0,  1.0,
            -1.0, -1.0,  1.0,

            // Right face
             1.0, -1.0, -1.0,
             1.0,  1.0, -1.0,
             1.0,  1.0,  1.0,
             1.0, -1.0,  1.0,

            // Left face
            -1.0, -1.0, -1.0,
            -1.0, -1.0,  1.0,
            -1.0,  1.0,  1.0,
            -1.0,  1.0, -1.0,
        ];

        const faceColors = [
            [1.0,  1.0,  1.0,  1.0],    // Front face: white
            [1.0,  0.0,  0.0,  1.0],    // Back face: red
            [0.0,  1.0,  0.0,  1.0],    // Top face: green
            [0.0,  0.0,  1.0,  1.0],    // Bottom face: blue
            [1.0,  1.0,  0.0,  1.0],    // Right face: yellow
            [1.0,  0.0,  1.0,  1.0],    // Left face: purple
        ];

        let colors = [];
        for (let i = 0; i < faceColors.length; i++) {
            const c = faceColors[i];
            colors = colors.concat(c, c, c, c);
        }

        const indices = [
            0,  1,  2,      0,  2,  3,    // front
            4,  5,  6,      4,  6,  7,    // back
            8,  9,  10,     8,  10, 11,   // top
            12, 13, 14,     12, 14, 15,   // bottom
            16, 17, 18,     16, 18, 19,   // right
            20, 21, 22,     20, 22, 23,   // left
        ];

        const positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);

        const colorBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors), gl.STATIC_DRAW);

        const indexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);

        // Camera and input
        let camera = {
            position: { x: 0, y: 0, z: 0 },
            rotation: { x: 0, y: 0, z: 0 },
        };
        let keys = {};
        let mouse = { x: 0, y: 0, sensitivity: 0.002 };
        canvas.requestPointerLock = canvas.requestPointerLock || canvas.mozRequestPointerLock;
        canvas.onclick = () => canvas.requestPointerLock();

        document.addEventListener('keydown', (e) => keys[e.code] = true);
        document.addEventListener('keyup', (e) => keys[e.code] = false);
        document.addEventListener('mousemove', (e) => {
            const x = e.movementX || 0;
            const y = e.movementY || 0;
            camera.rotation.y -= x * mouse.sensitivity;
            camera.rotation.x -= y * mouse.sensitivity;
            camera.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, camera.rotation.x));
        });

        // Update function
        function update() {
            const speed = 0.1;
            if (keys.KeyW || keys.ArrowUp) camera.position.z -= Math.cos(camera.rotation.y) * speed, camera.position.x -= Math.sin(camera.rotation.y) * speed;
            if (keys.KeyS || keys.ArrowDown) camera.position.z += Math.cos(camera.rotation.y) * speed, camera.position.x += Math.sin(camera.rotation.y) * speed;
            if (keys.KeyA || keys.ArrowLeft) camera.position.z -= Math.sin(camera.rotation.y) * speed, camera.position.x -= Math.cos(camera.rotation.y) * speed;
            if (keys.KeyD || keys.ArrowRight) camera.position.z += Math.sin(camera.rotation.y) * speed, camera.position.x += Math.cos(camera.rotation.y) * speed;
            if (keys.Space) camera.position.y += speed;
            else camera.position.y -= speed * 0.5;  // gravity
            camera.position.y = Math.max(0, camera.position.y);  // ground
            document.getElementById('position').textContent = camera.position.x.toFixed(2) + ', ' + camera.position.y.toFixed(2) + ', ' + camera.position.z.toFixed(2);
        }

        // Render function
        function render() {
            gl.clearColor(0.0, 0.0, 0.0, 1.0);
            gl.clearDepth(1.0);
            gl.enable(gl.DEPTH_TEST);
            gl.depthFunc(gl.LEQUAL);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

            const fieldOfView = 45 * Math.PI / 180;
            const aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;
            const zNear = 0.1;
            const zFar = 100.0;
            const projectionMatrix = mat4.create();
            mat4.perspective(projectionMatrix, fieldOfView, aspect, zNear, zFar);

            const modelViewMatrix = mat4.create();
            mat4.translate(modelViewMatrix, modelViewMatrix, [camera.position.x, camera.position.y, camera.position.z]);
            mat4.rotate(modelViewMatrix, modelViewMatrix, camera.rotation.y, [0, 1, 0]);
            mat4.rotate(modelViewMatrix, modelViewMatrix, camera.rotation.x, [1, 0, 0]);

            // Bind buffers
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.vertexAttribPointer(programInfo.attribLocations.vertexPosition, 3, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(programInfo.attribLocations.vertexPosition);

            gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
            gl.vertexAttribPointer(programInfo.attribLocations.vertexColor, 4, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(programInfo.attribLocations.vertexColor);

            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
            gl.useProgram(programInfo.program);
            gl.uniformMatrix4fv(programInfo.uniformLocations.projectionMatrix, false, projectionMatrix);
            gl.uniformMatrix4fv(programInfo.uniformLocations.modelViewMatrix, false, modelViewMatrix);

            // Draw cubes at different positions
            const cubePositions = [
                [0, 0, -5],
                [2, 0, -7],
                [-3, 0, -6],
                [1, 1.5, -8]
            ];
            cubePositions.forEach((pos) => {
                const mvMatrix = mat4.clone(modelViewMatrix);
                mat4.translate(mvMatrix, mvMatrix, pos);
                gl.uniformMatrix4fv(programInfo.uniformLocations.modelViewMatrix, false, mvMatrix);
                gl.drawElements(gl.TRIANGLES, indices.length, gl.UNSIGNED_SHORT, 0);
            });
        }

        // Simple matrix library (mat4)
        const mat4 = {
            create: () => new Float32Array(16),
            perspective: (out, fovy, aspect, near, far) => {
                const f = 1.0 / Math.tan(fovy / 2);
                out[0] = f / aspect; out[1] = 0; out[2] = 0; out[3] = 0;
                out[4] = 0; out[5] = f; out[6] = 0; out[7] = 0;
                out[8] = 0; out[9] = 0; out[10] = (far + near) / (near - far); out[11] = -1;
                out[12] = 0; out[13] = 0; out[14] = (2 * far * near) / (near - far); out[15] = 0;
                return out;
            },
            translate: (out, a, v) => {
                out[12] = a[12] + v[0]; out[13] = a[13] + v[1]; out[14] = a[14] + v[2]; out[15] = a[15];
                return out;
            },
            rotate: (out, a, rad, axis) => {
                let x = axis[0], y = axis[1], z = axis[2];
                let len = Math.sqrt(x * x + y * y + z * z);
                if (len < 0.000001) return mat4.clone(a);
                x /= len; y /= len; z /= len;
                const s = Math.sin(rad), c = Math.cos(rad), t = 1 - c;
                const a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
                const a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
                const a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
                out[0] = x * x * t + c; out[1] = y * x * t + z * s; out[2] = z * x * t - y * s; out[3] = 0;
                out[4] = x * y * t - z * s; out[5] = y * y * t + c; out[6] = z * y * t + x * s; out[7] = 0;
                out[8] = x * z * t + y * s; out[9] = y * z * t - x * s; out[10] = z * z * t + c; out[11] = 0;
                out[12] = a00 * out[0] + a10 * out[1] + a20 * out[2] + a00 * out[3];
                out[13] = a01 * out[4] + a11 * out[5] + a21 * out[6] + a01 * out[7];
                out[14] = a02 * out[8] + a12 * out[9] + a22 * out[10] + a02 * out[11];
                out[15] = a03 * out[12] + a13 * out[13] + a23 * out[14] + a03 * out[15];
                return out;
            },
            clone: (a) => {
                const out = new Float32Array(16);
                for (let i = 0; i < 16; ++i) out[i] = a[i];
                return out;
            }
        };

        // Game loop
        function gameLoop() {
            update();
            render();
            requestAnimationFrame(gameLoop);
        }
        gameLoop();
    </script>
</body>
</html>
</content>
</create_file>